# -*- coding: utf-8 -*-
"""Copy of Dunkin_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RYUA2go2D3IUFqB2QYiDY0GziXglO7SH

# **Dunkin Donuts Coffee Assignment 3**

Dunkin Donuts sells several different *types* and *sizes* of coffee products.


Each product must be specified by both a type and a size.  So, any particular product can be represented by a “tuple” with two values in it, such as
('Cappuccino', ‘Small') or ('Iced Coffee', 'Large').


*Quick Definition!* A "tuple" is a data type in Python; you can just think of a tuple as a list of data for now.


We will represent the coffee menu with a Python dictionary. This dictionary holds the prices of the different types and sizes of coffee products.

This assignment requires you to complete several functions. Some of these can be used to extract price information from the dictionary. Some of these can be used to modify price information in the dictionary.

Below, you'll find some starter code and associated prompts.

Each function has an associated "test" for you written below it. When you run your function, these tests will automatically run your function and display your function's output.

We have also provided you with the expected answer, so you can check for yourself if you have written functions that produce the expected answers! All you have to do is run the code block, and compare the printed values your functions produced with the expected values. The values we have provided as expected values are rounded, but we do not expect your functions to round numbers.

The values will be printed as numbers, not as dollars - this is to be expected!

## Turning in the Assignment

When you think that you have your code working, download it as a .py file and submit it to GradeScope. You will need to make sure to remove the "Copy of" prefix from the title before doing so. If you do not get full credit, you can revise your code and resubmit it to GradeScope as many times as you like before the due date.

If you have questions about getting your Python code to work, email the TA or the Instructor.  And if you're contacting someone for help with code, it may be helpful to send them a shareable link to your Colab file to go over.  You can also set up a time to go over your assignment in person or over Zoom.

The follow code defines some **global variables**, meaning that they will be accessible in the rest of the code blocks below.  It also imports a couple of functions from libraries.  And it defines a couple of helper functions (that should look familar) that you can use in writing your code.
"""

from math import sqrt
from pprint import pprint

# These variables are constants that represent the type and size specifications.
TYPE = 0
SIZE = 1

dunkin_small_menu = {'Coffee': 1.69, 'Latte': 2.79, 'Cappuccino': 2.69, \
                     'Macchiato': 3.49, 'Iced Coffee': 2.49, 'Cold Brew': 2.99, \
                     'Iced Latte': 3.29, 'Iced Macchiato': 3.99, \
                     'Coffee Coolatta': 2.99}

dunkin_multiplier = {'Small': 1.0, 'Medium': 1.25, 'Large': 1.5}

def get_price(menu, key):
    """ This function returns the price of a menu item. """

    # return 0 if the items is not in the menu
    val = 0

    # if the item is in the menu, get its price
    if key in menu:
        val = menu[key]

    return val

def set_price(menu, key, val):
    """ This function sets the price of a menu item to a particular value. """

    menu[key] = val

"""The first function you will write will be called **create_full_menu**. The purpose of this function is to initialize, or create, the dictionary that holds the menu prices. In the previous assignment, you were given the full menu.  In this assignment, you will need to create it.  

In order to do this, you will start with two dictionaries, 'small_menu', a dictionary that holds the prices of the small items and 'multiplier', a dictionary that tells you how to multiply those prices to get the prices of the other items.  You will put the full menu in the empty dictionary, 'full_menu'.

As a reminder, a dictionary is a data structure in python that consists of "keys" and their associated "values". There is no limit on the number of keys or values a dictionary can hold, but keys cannot be replaced. For example, you may have dict = {'Teacher': 'Prof. Fallis', 'Students': ['Marta', 'Kevin', 'Ryan']}. In this dictionary, the keys are 'Teacher' and 'Students' and the values are 'Prof. Fallis', which is attached to the key 'Teacher', and ['Marta', 'Kevin', 'Ryan'], which is attached to the key 'Students'.

To complete this function, think about the relationship between the two dictionaries small_menu and multiplier, and the final, or full_menu, dictionary.  This function initiallzes the dictionary that holds the prices.

Note that the keys in the small menu are types of coffee, such as ‘Latte’ and that the keys in the multiplier are sizes of coffee, such as ‘Medium’.  But just like in the previous assignment, the keys in the full menu should be **tuples** of types and sizes of coffee, such as (‘Latte’, ‘Medium’).
        
Input
    
- small_menu: A dictionary that holds the prices of the small items.
        
- multiplier: A dictionary that tells us how to multiply the prices of SMALL items to get the prices of MEDUIM and LARGE items.

Output

- full_menu: The name of the dictionary that holds the full menu of prices.
"""

def create_full_menu(small_menu, multiplier):

    full_menu = {}

    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    for item in small_menu:
      for type in multiplier:
        full_menu[item, type] = small_menu[item] * multiplier[type]

    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return full_menu

dunkin_full_menu = create_full_menu(dunkin_small_menu, dunkin_multiplier)
print("What are the prices for all of Dunkin Donut's coffee products?")
print("Your answer:")
pprint(dunkin_full_menu)
print("Expected answer:")
pprint({('Coffee', 'Small'): 1.69, ('Coffee', 'Medium'): 2.11, ('Coffee', 'Large'): 2.54, ('Latte', 'Small'): 2.79, ('Latte', 'Medium'): 3.49, ('Latte', 'Large'): 4.19, ('Cappuccino', 'Small'): 2.69, ('Cappuccino', 'Medium'): 3.36, ('Cappuccino', 'Large'): 4.04, ('Macchiato', 'Small'): 3.49, ('Macchiato', 'Medium'): 4.36, ('Macchiato', 'Large'): 5.24, ('Iced Coffee', 'Small'): 2.49, ('Iced Coffee', 'Medium'): 3.11, ('Iced Coffee', 'Large'): 3.74, ('Cold Brew', 'Small'): 2.99, ('Cold Brew', 'Medium'): 3.74, ('Cold Brew', 'Large'): 4.49, ('Iced Latte', 'Small'): 3.29, ('Iced Latte', 'Medium'): 4.11, ('Iced Latte', 'Large'): 4.94, ('Iced Macchiato', 'Small'): 3.99, ('Iced Macchiato', 'Medium'): 4.99, ('Iced Macchiato', 'Large'): 5.99, ('Coffee Coolatta', 'Small'): 2.99, ('Coffee Coolatta', 'Medium'): 3.74, ('Coffee Coolatta', 'Large'): 4.49})

"""This function, total_price, calculates the total price of buying each specification of a
certain product, so the total price of buying every MEDIUM product on the
menu or every LATTE on the menu, for instance. It is **not** calculating the
total price of every single item on the menu!

You have been provided already with the variable "tot", which you will in some way have to calculate, and then return at the end of your function.

Input

- menu: The name of a dictionary that holds the full menu of prices.

- product: A type or size specification for a beverage.

Output

- tot: The total price of buying each specification of a certain product.
"""

def get_total_price(menu, product):

    tot = 0

    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    for tuple in menu:
      if (product == None): # no type/size specification, add all
        tot += menu[tuple]
      if (tuple[0] == product) | (tuple[1] == product):
        tot += menu[tuple]

    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return tot

print("How much does it cost to buy one of each of Dunkin Donut's coffee products?")
print("Your answer: ", get_total_price(dunkin_full_menu, None))
print("Expected result: 99.04")
print("")

print("How much does it cost to buy one of each of Dunkin Donut's LARGE coffee products?")
print("Your answer: ", get_total_price(dunkin_full_menu, 'Large'))
print("Expected result: 39.62")
print("")

print("How much does it cost to buy one of each of Dunkin Donut's COFFEE COOLATTA products?")
print("Your answer: ", get_total_price(dunkin_full_menu, 'Coffee Coolatta'))
print("Expected result: 11.21")

"""  This function calculates the average price of a specification of a product,
  so the average cost of all MEDIUM drinks on the menu or the average cost
  of all LATTEs on the menu. It is **not** the average cost of every single item
  on the menu!

  You have again been given an "ave" variable, which you will calculate and then return.


Input


  - menu: The name of a dictionary that holds the full menu of prices.

  - product: A type or size specification for a beverage.

Output


  - ave: The average cost of a specification of a product.

"""

def get_average_price(menu, product):

    ave = 0

    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #
    count = 0
    for tuple in menu:
      if (product == None) | (tuple[0] == product) | (tuple[1] == product):
        count = count + 1

    ave = round(get_total_price(menu, product) / count, 2)
    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return ave

print("What does it cost on average to buy a MEDIUM coffee product?")
print("Your answer: ", get_average_price(dunkin_full_menu, 'Medium'))
print("Expected result: 3.67")
print("")

print("What does it cost on average to buy an ICED LATTE?")
print("Your answer: ", get_average_price(dunkin_full_menu, 'Iced Latte'))
print("Expected result: 4.11")

"""Strangely enough, Dunkin Donuts decides to give away a certain type
of product, such as all LARGE products or all COLD BREW products
away for free.  So, it is useful to have a function that does this
in one fell swoop.

This function updates the data structure that represents the menu
based on what type of product is to be given away for free.

Input
    
- menu: The name of a dictionary that holds the full menu of prices.
    
- product: The type of product is to be given away for free.

Output

- none
"""

def set_price_zero(menu, product):

    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    for tuple in menu:
      if (tuple[0] == product) | (tuple[1] == product):
        menu[tuple] = 0

    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return

print("Suppose that Dunkin Donuts decides to give away all MEDIUM products.")
set_price_zero(dunkin_full_menu, 'Medium')
print("Now, what does it cost on average to buy an ICED LATTE?")
print("Your answer: ", get_average_price(dunkin_full_menu, 'Iced Latte'))
print("Expected result: 2.74")
print("")

# This line of code re-initializes the menu so that product prices are returned
# to their original state.
dunkin_full_menu = create_full_menu(dunkin_small_menu, dunkin_multiplier)

print("Suppose that Dunkin Donuts decides to give away all ICED MACCHIATO products instead.")
set_price_zero(dunkin_full_menu, 'Iced Macchiato')
print("Now, what does it cost on average to buy a MEDIUM coffee product?")
print("Your answer: ", get_average_price(dunkin_full_menu, 'Medium'))
print("Expected result: 3.11")

# This line of code re-initializes the menu so that product prices are returned
# to their original state.
dunkin_full_menu = create_full_menu(dunkin_small_menu, dunkin_multiplier)

"""Also, sometimes, Dunkin Donuts decides to set the price of a product to
    the square root of the ordinary price of that product as a promototion,
    such as setting all LARGE products or all COLD BREW products to the square
    root of the typical price.  So, it is also useful to have a function that
    does this in one fell swoop.

  This function updates the data structure that represents the menu
    based on what type of product is to be given away for the square root
    of the typical price.

                            
Input
    
- menu: The name of a dictionary that holds the full menu of prices.
    
- product: The type of product is to be sold at the new price point.

Output

- none
"""

def set_price_sqrt(menu, product):

    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    for tuple in menu:
      if (tuple[0] == product) | (tuple[1] == product):
        menu[tuple] = sqrt(menu[tuple])

    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return

print("Suppose that Dunkin Donuts decides to just take the square root of all MEDIUM products instead.")
set_price_sqrt(dunkin_full_menu, 'Medium')
print("Now, what does it cost on average to buy an ICED LATTE?")
print("Your answer: ", get_average_price(dunkin_full_menu, 'Iced Latte'))
print("Expected result: 3.42")

# This line of code re-initializes the menu so that product prices are returned
# to their original state.
dunkin_full_menu = create_full_menu(dunkin_small_menu, dunkin_multiplier)

"""  Strangely enough, some stores do not sell individual products.  They
    just sell sets of products consisting of one of each along a
    particular dimension.  For example, you might buy a LARGE of each
    type of coffee product.  Or you might buy a CAPPUCCINO of all three sizes.  
    Thus, it is useful to be able to take the full menu and create a
    condensed menu for either of the two dimensions.

  This function consults the dictionary that represents the menu and
    returns a dictionary which holds the total price for one of each
    along a given dimension.

  You've been provided with a new_menu variable to modify and return.

                                  
Input
    
- menu: The name of a dictionary that holds the full menu of prices.
    
- axis: The dimension to be used.  Either TYPE or SIZE.
                
Output
    
- new_menu: The dictionary for the dimension specified by axis.
"""

def create_one_of_each(menu, axis):

    new_menu = {}

    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    for tuple in menu:
      if (axis == 0):
          new_menu[tuple[0]] = get_total_price(menu, tuple[0])
      else:
          new_menu[tuple[1]] = get_total_price(menu, tuple[1])

    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return new_menu

print("What are the prices for sets based on type of coffee?")
print("Your answer: ", create_one_of_each(dunkin_full_menu, TYPE))
print("Expected result: {'Coffee': 6.34, 'Latte': 10.46, 'Cappuccino': 10.09, 'Macchiato': 13.09, 'Iced Coffee': 9.34, 'Cold Brew': 11.21, 'Iced Latte': 12.34, 'Iced Macchiato': 14.96, 'Coffe Coolatta': 11.21}")
print("")

print("What are the prices for sets based on size of coffee?")
print("Your answer: ", create_one_of_each(dunkin_full_menu, SIZE))
print("Expected result: {'Small': 26.41, 'Medium': 33.01, 'Large': 39.62}")

"""That's the end! Good job on the assignment :)"""