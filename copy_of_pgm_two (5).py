# -*- coding: utf-8 -*-
"""Copy of PGM Two.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DkjAPcY5ZLpjpOTZgOlGO-dUUTCDCXwQ

# **Inference With a Two Node Probabilistic Graphical Model**

Probabilistic Graphical Models (PGM) can be handy for solving Bayesian Inference problems. For instance, suppose that we are interested in whether or not a patient has chicken pox. And suppose that, in order to make this determination, we can check whether or not the patient has spots. We might represent this problem using the following PGM:

![picture](https://drive.google.com/uc?export=view&id=1-ZTRu_MLaSf2WwsaDpqUnRoMMFbbVSaU)

To fully specify the PGM, we also need a node potential for one node in the graph and an edge potential for each edge in the graph.

In this case, a node potential might be represented using a Python dictionary, such as Node_N0 = {'NOPOX': 0.9, 'POX': 0.1}. Also, an edge potential might be represented using a Python dictionary of dictionaries, such as Edge_N0_N1 = {'NOPOX': {'NOSPOTS': 0.999, 'SPOTS': 0.001}, 'POX': {'NOSPOTS': 0.2, 'SPOTS': 0.8}}.

This assignment asks you to write code to carry out Bayesian Inference using a PGM with the same structure as the diagram above. This assignment requires you to work from the template code that I am providing. You need to complete the following four functions. See the comments at the beginning of the functions for details about what the expected inputs and outputs are.

- normalize_table()
- create_joint_table()
- update_table()
- create_marginalized()

This assignment is very similar to the Conditionalization programming assignment in that it is also asking you to implement Bayesian Inference. It is just asking you to do it specifically by implementing the various steps of the Master Method. The create_joint_table() function is Step 1. The update_table() function is Steps 2 and 3. And the create_marginalized() function is Step 4.

## Tips

- In the Chicken Pox example, both random variables take on just two possible values. But your functions should place no restrictions on the number of possible values.

- In the template code, I give the probabilities in the "Expected Answer" rounded to 3 decimal places. You should not round the probabilities when you write your functions.

- You may want to make use of some of your code from previous programming assignments when you write these functions.

- If you wish, you can create additional helper functions. You can also add code to the program to test your functions. But do not change the existing function definitions and names as they must remain consistent for grading!

- Remember that you can add (key, value) pairs to a Python dictionary (dict) using the following syntax: dict[key] = value

- You might want to test your functions using examples of probabilistic inference from the lecture slides.

- Remember to use good coding practices (include comments, use meaningful names for variables, etc.).

## Turning in the Assignment

When you think that you have your code working, download it as a .py file and submit it to GradeScope. You will need to make sure to remove the "Copy of" prefix from the title before doing so. If you do not get full credit, you can revise your code and resubmit it to GradeScope as many times as you like before the due date.

If you have questions about getting your Python code to work, email the TA or the Instructor. And if you're contacting someone for help with code, it may be helpful to send them a shareable link to your Colab file to go over. You can also set up a time to go over your assignment in person or over Zoom.

Here are a couple of helper functions that we have seen before and that you can use in writing your code:
"""

def get_cell(table, key):
    """This function returns the value in a particular cell of a probability table."""

    val = 0

    # return 0 if the key is not in the table
    if key in table:
        val = table[key]

    return val


def total_prob(table):
    """This function returns the total of all of the values in a probability table."""

    tot = 0

    for key in table:
        tot += get_cell(table, key)

    return tot

"""**The 'normalize_table' function turns a probability distribution into a VALID probability distribution.** More precisely, the probabilities are adjusted so that they (a) add up to 1 and (b) are in the same ratios as they were originally.

_Input_

- table: A probability distribution represented as a Python dictionary.

_Output_

- none

"""

def normalize_table(table):
    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    total = total_prob(table)
    if total == 0:
        return   # avoid error: don't divide by 0
    for key in table:
        table[key] /= total


    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return

firefly_table = {"Good": 1 / 3, "Bad": 1 / 2, "Ugly": 1 / 6}
normalize_table(firefly_table)

print("The male firefly's prior is ", firefly_table)

"""**The 'create_joint_table' function starts with a PGM with 2 nodes (i.e., two random variables) and it creates a joint probability distribution for those two random variables.** It takes as input one node potentiol (for node N0) and one edge potential (for the edge from N0 to N1).

_Input_

- node_0: A prior probability distribution represented as a Python dictionary; node_0[h] gives the (unconditional) probability that h is the value of N0.

- edge_0_1: A set of conditional probability distributions represented as
  a Python dictionary of dictionaries; edge_0_1[h][e] gives the (conditional) probability that e is value of N1 given that h is the value of N0 (i.e., edge_0_1[h][e] equals P(N1 = e | N0 = h).

_Output_

A joint probability distribution represented as a Python dictionary; table [(h, e)] gives the probability of h and e occurring together (i.e., table [(h, e)] equals P(N0 = h & N1 = e).

"""

def create_joint_table(node_0, edge_0_1):
    joint_table = {}

    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    for h in node_0:
        for e in edge_0_1[h]:
            joint_table[(h, e)] = edge_0_1[h][e] * node_0[h]

    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return joint_table

chicken_pox_node = {"NOPOX": 0.9, "POX": 0.1}
chicken_pox_spots_edge = {
    "NOPOX": {"NOSPOTS": 0.999, "SPOTS": 0.001},
    "POX": {"NOSPOTS": 0.2, "SPOTS": 0.8},
}

print("The joint probability is ", create_joint_table(chicken_pox_node, chicken_pox_spots_edge))

"""**The 'update_table' function updates the joint probability distribution based on the evidence that is observed.**

_Input_

- table: A joint probability distribution represented as a Python dictionary.
- observed: the evidence e that is observed.
- axis: the random variable from which e was observed, either 0 or 1

Note that we have to specify the random variable because two different radom variables could have some of the same possible values.

_Output_

- none

"""

def update_table(table, evidence, axis):
    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    for h, e in table:
      if axis == 0 and h != evidence:
          table[h, e] = 0
      elif axis == 1 and e != evidence:
          table[h, e] = 0


    normalize_table(table)

    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return

chicken_pox_node = {"NOPOX": 0.9, "POX": 0.1}
chicken_pox_spots_edge = {
    "NOPOX": {"NOSPOTS": 0.999, "SPOTS": 0.001},
    "POX": {"NOSPOTS": 0.2, "SPOTS": 0.8},
}
joint_prob = create_joint_table(chicken_pox_node, chicken_pox_spots_edge)
print(joint_prob)
update_table(joint_prob, 'SPOTS', 1)
print("The updated table is ", joint_prob)

"""**The 'create_marginalized' function starts with the joint probability distribution for two random variables and returns the probability distribution for one of the two random variables.** Basically, you have to use the law of total probabilities (several times) to calculate the probability of each value of that random variable.

Input

- table: A joint probability distribution represented as a Python dictionary.
- axis: The random variable to be marginalized, either 0 or 1

Output

- dist: If x is the value of axis, dist is the current probability distribution for random variable Nx represented as a Python dictionary.

"""

def create_marginalized(joint_table, axis):
    new_table = {}

    # -------------------------------------------------------------------------
    # YOUR CODE GOES HERE
    #

    for h, e in joint_table:
        if axis == 0:
            if h in new_table:
                new_table[h] += joint_table[(h, e)]
            else:
                new_table[h] = joint_table[(h, e)]
        else: # axis == 1
            if e in new_table:
                new_table[e] += joint_table[(h, e)]
            else:
                new_table[e] = joint_table[(h, e)]



    #
    # END OF YOUR CODE
    # -------------------------------------------------------------------------

    return new_table

chicken_pox_node = {"NOPOX": 0.9, "POX": 0.1}
chicken_pox_spots_edge = {
    "NOPOX": {"NOSPOTS": 0.999, "SPOTS": 0.001},
    "POX": {"NOSPOTS": 0.2, "SPOTS": 0.8},
}
joint_prob = create_joint_table(chicken_pox_node, chicken_pox_spots_edge)
print(joint_prob)
update_table(joint_prob, 'SPOTS', 1)
print(joint_prob)
create_marginalized(joint_prob, 1)
print(joint_prob)

"""**The 'create_conditionalized' function takes (a) an agent's prior probability distribution over a set of hypotheses, (b) the agent's likelihoods, and (c) a piece of evidence to determine a posterior probability distribution over the set of hypotheses.** It is already written for you. It implements the Master Method using the functions that you are writing.

Input

- prior: A prior probability distribution represented as a Python dictionary;
  prior[e] gives the (unconditional) probability that e is the outcome.

- conditional: A set of conditional probability distributions represented as a Python dictionary of dictionaries; conditional[h][e] gives the (conditional) probability that e is the evidence that is observed given that hypothesis h is true; i.e., conditional[h][e] equals P(e | h).

- observed: The evidence e that is observed.

Output

- posterior: A posterior probability distribution represented as a Python dictionary.

"""

def create_conditionalized(prior, conditional, evidence):
    # construct joint probability table (Step 1 of Master Method)
    joint_table = create_joint_table(prior, conditional)

    # update joint probability table after observing the value of N1 (Steps 2 and 3 of Master Method)
    update_table(joint_table, evidence, 1)

    # marginalize to get probability distribution for N0 (Step 4 of Master Method)
    posterior = create_marginalized(joint_table, 0)

    return posterior

"""The following code tests the 'create_conditionalized' function using the **Chicken Pox** example. Basically, we inferring the probability of the patient having chicken pox based on the evidence that they have spots.

"""

chicken_pox_prior = {"NOPOX": 0.9, "POX": 0.1}
chicken_pox_spots_conditional = {
    "NOPOX": {"NOSPOTS": 0.999, "SPOTS": 0.001},
    "POX": {"NOSPOTS": 0.2, "SPOTS": 0.8},
}

print("The doctor's prior regarding chicken pox is ", chicken_pox_prior)

print("Suppose that the patient has spots.")
chicken_pox_posterior = create_conditionalized(
    chicken_pox_prior, chicken_pox_spots_conditional, "SPOTS"
)

print("My Answer:")
print("The doctor's posterior regarding chicken pox is ", chicken_pox_posterior)
print("Expected Answer:")
print(
    "The doctor's posterior regarding chicken pox is ", {
        "NOPOX": 0.011, "POX": 0.989}
)

"""The following code tests the 'create_conditionalized' function using the case of inferring the probability that a firefly belongs to a particular species based on the evidence of color of the firefly's flash.

"""

firefly_prior = {"Good": 1 / 3, "Bad": 1 / 3, "Ugly": 1 / 3}
firefly_flash_conditional = {
    "Good": {"YELLOW": 1, "WHITE": 0},
    "Bad": {"YELLOW": 1, "WHITE": 0},
    "Ugly": {"YELLOW": 0, "WHITE": 1},
}

print("The male firefly's prior is ", firefly_prior)

print("Suppose that he sees a Yellow flash.")
firefly_posterior = create_conditionalized(
    firefly_prior, firefly_flash_conditional, "YELLOW"
)

print("My Answer:")
print("The male firefly's posterior is ", firefly_posterior)
print("Expected Answer:")
print("The male firefly's posterior is ", {
      "Good": 0.500, "Bad": 0.500, "Ugly": 0.000})

print("SIX TESTS (1 point off for each failed test)")
print("")

chicken_pox_prior = {"NOPOX": 0.9, "POX": 0.1}
chicken_pox_fever_conditional = {
    "NOPOX": {"NOFEVER": 0.95, "FEVER": 0.05},
    "POX": {"NOFEVER": 0.4, "FEVER": 0.6},
}

# test create_joint_table()
chicken_pox_fever_table = create_joint_table(
    chicken_pox_prior, chicken_pox_fever_conditional
)
val = get_cell(chicken_pox_fever_table, ("NOPOX", "FEVER"))
print("My Answer:")
print("The probability of the patient having fever without chicken pox is ", val)
print("Expected Answer:")
print("The probability of the patient having fever without chicken pox is ", 0.045)
print("")

# test marginalize() before calling update()
new_chicken_pox = create_marginalized(chicken_pox_fever_table, 1)
print("My Answer:")
print("The marginal probability distribution for fever is ", new_chicken_pox)
print("Expected Answer:")
print(
    "The marginal probability distribution for fever is ",
    {"NOFEVER": 0.895, "FEVER": 0.105},
)
print("")

# test update_table()
print("Suppose that the patient has fever.")
update_table(chicken_pox_fever_table, "FEVER", 1)
val = get_cell(chicken_pox_fever_table, ("NOPOX", "FEVER"))
print("My Answer:")
print("The probability of the patient having fever without chicken pox is ", val)
print("Expected Answer:")
print("The probability of the patient having fever without chicken pox is ", 0.429)
print("")

firefly_prior = {"Good": 1 / 2, "Bad": 1 / 4, "Ugly": 1 / 4}
firefly_flash_conditional = {
    "Good": {"YELLOW": 1, "WHITE": 0},
    "Bad": {"YELLOW": 1, "WHITE": 0},
    "Ugly": {"YELLOW": 0, "WHITE": 1},
}
firefly_flash_table = create_joint_table(
    firefly_prior, firefly_flash_conditional)

# test create_joint_table()
val = get_cell(firefly_flash_table, ("Good", "YELLOW"))
print("My Answer:")
print(
    "The probability that it is a Good female firefly and that she gives a Yellow flash is ",
    val,
)
print("Expected Answer:")
print(
    "The probability that it is a Good female firefly and that she gives a Yellow flash is ",
    0.5,
)
print("")

# test update()
print("Suppose that the male firefly sees a Yellow flash.")
update_table(firefly_flash_table, "YELLOW", 1)
val = get_cell(firefly_flash_table, ("Good", "YELLOW"))
print("My Answer:")
print(
    "The probability that it is a Good female firefly and that she gives a Yellow flash is ",
    val,
)
print("Expected Answer:")
print(
    "The probability that it is a Good female firefly and that she gives a Yellow flash is ",
    0.667,
)
print("")

# test marginalize() after calling update()
new_firefly = create_marginalized(firefly_flash_table, 0)
print("My Answer:")
print(
    "The marginal probability distribution for type of female firefly is ", new_firefly
)
print("Expected Answer:")
print(
    "The marginal probability distribution for type of female firefly is ",
    {"Good": 0.667, "Bad": 0.333, "Ugly": 0.000},
)

counterfeit_prior = {
    "#1": 1 / 9,
    "#2": 1 / 9,
    "#3": 1 / 9,
    "#4": 1 / 9,
    "#5": 1 / 9,
    "#6": 1 / 9,
    "#7": 1 / 9,
    "#8": 1 / 9,
    "#9": 1 / 9,
}
counterfeit_ask_joe_conditional = {
    "#1": {"YES": 1, "NO": 0},
    "#2": {"YES": 0, "NO": 1},
    "#3": {"YES": 0, "NO": 1},
    "#4": {"YES": 0, "NO": 1},
    "#5": {"YES": 0, "NO": 1},
    "#6": {"YES": 0, "NO": 1},
    "#7": {"YES": 0, "NO": 1},
    "#8": {"YES": 0, "NO": 1},
    "#9": {"YES": 0, "NO": 1},
}

print("My prior for the location of the counterfeit coin is ", counterfeit_prior)

print("Suppose that Joe says that coin #1 is NOT counterfeit.")
counterfeit_posterior = create_conditionalized(
    counterfeit_prior, counterfeit_ask_joe_conditional, "NO"
)

print("My Answer:")
print("My posterior is", counterfeit_posterior)
print("Expected Answer:")
print(
    "My posterior is ",
    {
        "#1": 0,
        "#2": 1 / 8,
        "#3": 1 / 8,
        "#4": 1 / 8,
        "#5": 1 / 8,
        "#6": 1 / 8,
        "#7": 1 / 8,
        "#8": 1 / 8,
        "#9": 1 / 8,
    },
)